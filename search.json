[{"title":"Android IPC 之 AIDL（二）","url":"/2018/05/08/AIDL-2/","content":"上一节，在[Android IPC 之 AIDL（一）]()中我们知道了AIDL的简单使用方法，但是其中有很多细节并不是很清楚，这一节我们来了解一下Java层的Binder机制，看看客户端和服务端到底是怎样实现通信的。\n\n我们再来看一下客户端的代码：\n\n```Java\npackage com.vera.aidltest;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.os.RemoteException;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.Button;\npublic class ClientActivity extends AppCompatActivity {\nButton mButton;\nprivate ServiceConnection myConnection=new ServiceConnection() {\n    @Override\n    public void onServiceConnected(ComponentName componentName, IBinder iBinder) {\n        IMyAdd mMyAdd=IMyAdd.Stub.asInterface(iBinder);\n        try {\n            int result=mMyAdd.myAdd(1,2);\n            Log.d(\"ClientActivity\",\"get the result is \"+result);\n        } catch (RemoteException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public void onServiceDisconnected(ComponentName componentName) {\n    }\n};\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_client);\n    mButton=(Button)findViewById(R.id.activity_client_mbutton);\n    mButton.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    Intent intent=new Intent(ClientActivity.this,ServerService.class);\n                    bindService(intent,myConnection, Context.BIND_AUTO_CREATE);\n                    }\n    });\n}\n@Override\nprotected void onDestroy(){\n    unbindService(myConnection);\n    super.onDestroy();\n}\n}\n```\n客户端仅仅做了两件事，第一，重写的ServiceConnection类中的两个方法，第二，绑定服务端并启动。通信肯定是从绑定服务开始的，即bindService()方法。我们知道，bindService()方法接收了一个ServiceConnection对象的参数，在经过各种调用建立客户端和服务端的连接后，系统会调用ServiceConnection中的onServiceConnected()方法。我们在这个方法里拿到一个IBinder对象。这个IBinder对象从哪里来呢？我们再来看服务端的代码：\n```Java\npackage com.vera.aidltest;\nimport android.app.Service;\nimport android.content.Intent;\nimport android.os.Binder;\nimport android.os.IBinder;\nimport android.os.RemoteException;\nimport android.util.Log;\npublic class ServerService extends Service {\nprivate Binder mBinder=new IMyAdd.Stub(){\n    @Override\n    public int myAdd(int num_a, int num_b) throws RemoteException {\n        int result=num_a+num_b;\n        Log.d(\"ServerService\",\"the result of \"+num_a+\" and \"+num_b+\" is \"+result);\n        return result;\n        }\n};\n@Override\npublic IBinder onBind(Intent intent) {\n    return mBinder;\n}\n}\n```\n这个IBinder对象就是服务端的本地Binder对象，在onBind()方法中，它被向上转型并返回给客户端。为什么我们的Binder类要实现IBinder接口呢？我们看一下IBinder的官方文档怎么写：\n\nBase interface for a remotable object, the core part of a lightweight remote procedure call mechanism designed for high performance when performing in-process and cross-process calls. This interface describes the abstract protocol for interacting with a remotable object. Do not implement this interface directly, instead extend from Binder.\n\n翻译过来就是：\n\nIBinder是远程对象的基本接口，是为高性能而设计的轻量级远程调用机制的核心部分。但它不仅用于远程调用，也用于进程内调用。这个接口定义了与远程对象交互的协议。不要直接实现这个接口，而应该从Binder派生。\n\n就是因为实现了IBinder接口，Binder对象才具备了跨进程传输的能力，这是底层支持的。\n\n然而，这里我们在客户端拿到的IBinder对象并不是服务端的本地对象(Binder类型)，仅仅只是该对象的代理(BinderProxy类型，Binder的内部类)。事实上，并不存在真正的Binder对象跨进程传输，不同进程间传递的Binder本地对象，在经过内核驱动时，都会被转化成为代理。这里我们屏蔽底层细节，只需要知道，这个代理对于客户端来说和真正的Binder对象没有区别。\n\n好了，既然拿到了我们的IBinder对象，之后客户端做了什么呢？\n\n```Java\nIMyAdd mMyAdd=IMyAdd.Stub.asInterface(iBinder);\n```\n客户端调用了远程的asInterface()方法！，我们再来看一下系统为我们生成的Java接口：\n\n```Java\n/*\n* This file is auto-generated.  DO NOT MODIFY.\n* Original file:\n*/\npackage com.vera.aidltest;\npublic interface IMyAdd extends android.os.IInterface\n{\n/** Local-side IPC implementation stub class. */\npublic static abstract class Stub extends android.os.Binder implements com.vera.aidltest.IMyAdd\n{\nprivate static final java.lang.String DESCRIPTOR = \"com.vera.aidltest.IMyAdd\";\n/** Construct the stub at attach it to the interface. */\npublic Stub()\n{\nthis.attachInterface(this, DESCRIPTOR);\n}\n/**\n* Cast an IBinder object into an com.vera.aidltest.IMyAdd interface,\n* generating a proxy if needed.\n*/\npublic static com.vera.aidltest.IMyAdd asInterface(android.os.IBinder obj)\n{\nif ((obj==null)) {\nreturn null;\n}\nandroid.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\nif (((iin!=null)&&(iin instanceof com.vera.aidltest.IMyAdd))) {\nreturn ((com.vera.aidltest.IMyAdd)iin);\n}\nreturn new com.vera.aidltest.IMyAdd.Stub.Proxy(obj);\n}\n@Override public android.os.IBinder asBinder()\n{\nreturn this;\n}\n@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException\n{\nswitch (code)\n{\ncase INTERFACE_TRANSACTION:\n{\nreply.writeString(DESCRIPTOR);\nreturn true;\n}\ncase TRANSACTION_myAdd:\n{\ndata.enforceInterface(DESCRIPTOR);\nint _arg0;\n_arg0 = data.readInt();\nint _arg1;\n_arg1 = data.readInt();\nint _result = this.myAdd(_arg0, _arg1);\nreply.writeNoException();\nreply.writeInt(_result);\nreturn true;\n}\n}\nreturn super.onTransact(code, data, reply, flags);\n}\nprivate static class Proxy implements com.vera.aidltest.IMyAdd\n{\nprivate android.os.IBinder mRemote;\nProxy(android.os.IBinder remote)\n{\nmRemote = remote;\n}\n@Override public android.os.IBinder asBinder()\n{\nreturn mRemote;\n}\npublic java.lang.String getInterfaceDescriptor()\n{\nreturn DESCRIPTOR;\n}\n@Override\npublic int myAdd(int num_a, int num_b) throws android.os.RemoteException\n{\nandroid.os.Parcel _data = android.os.Parcel.obtain();\nandroid.os.Parcel _reply = android.os.Parcel.obtain();\nint _result;\ntry {\n_data.writeInterfaceToken(DESCRIPTOR);\n_data.writeInt(num_a);\n_data.writeInt(num_b);\nmRemote.transact(Stub.TRANSACTION_myAdd, _data, _reply, 0);\n_reply.readException();\n_result = _reply.readInt();\n}\nfinally {\n_reply.recycle();\n_data.recycle();\n}\nreturn _result;\n}\n}\nstatic final int TRANSACTION_myAdd = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n}\npublic int myAdd(int num_a, int num_b) throws android.os.RemoteException;\n}\n```\n之前我们说，这个接口包含了静态内部抽象类Stub，即本地Binder，并且声明了myAdd()方法。那么Stub类里到底都有些什么？我们来看一下：\n- DESCRIPTOR静态域 一个String类对象，一般为当前Binder的类名表示，它唯一确定了当前的Binder\n- asInterface()方法\n- asBinder()方法 它返回了当前Binder对象\n- onTransact()方法\n- Proxy静态内部类\n\n我们来看客户端调用的asInterface()方法。\n\n```Java\n/**\n* Cast an IBinder object into an com.vera.aidltest.IMyAdd interface,\n* generating a proxy if needed.\n*/\npublic static com.vera.aidltest.IMyAdd asInterface(android.os.IBinder obj)\n{\nif ((obj==null)) {\nreturn null;\n}\nandroid.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\nif (((iin!=null)&&(iin instanceof com.vera.aidltest.IMyAdd))) {\nreturn ((com.vera.aidltest.IMyAdd)iin);\n}\nreturn new com.vera.aidltest.IMyAdd.Stub.Proxy(obj);\n}\n```\n客户端调用方法传入了IBinder对象参数，在asInterface()方法中，IBinder对象被查看是否有LocalReference，即查看传入的IBinder是Binder本地对象（Binder类型）还是代理（BinderProxy类型）。如果是本地对象，则直接返回转型后的接口对象，如果不是，则另外创建Binder代理返回。本例中客户端和服务端不处于同一进程，传入的IBinder对象是代理，那么函数返回的就是我们的Proxy代理类的对象。\n\n好了，现在回到客户端。远程调用asInterface()方法后，我们在客户端得到了一个Proxy代理类向上转型后的接口对象，并调用了它的myAdd()方法。注意，从这里开始，客户端的这个线程就挂起，直到等待到myAdd()方法的返回值。我们来看一下myAdd()方法在Proxy类里的具体实现：\n\n```Java\npublic int myAdd(int num_a, int num_b) throws android.os.RemoteException\n{\nandroid.os.Parcel _data = android.os.Parcel.obtain();\nandroid.os.Parcel _reply = android.os.Parcel.obtain();\nint _result;\ntry {\n_data.writeInterfaceToken(DESCRIPTOR);\n_data.writeInt(num_a);\n_data.writeInt(num_b);\nmRemote.transact(Stub.TRANSACTION_myAdd, _data, _reply, 0);\n_reply.readException();\n_result = _reply.readInt();\n}\nfinally {\n_reply.recycle();\n_data.recycle();\n}\nreturn _result;\n}\n```\n可以看到，myAdd()方法首先通过Parcel将传入的两个参数序列化，然后调用了mRemote的Transact()方法。mRemote是什么呢？是我们之前传入的代理类对象，即BinderProxy类的对象。它的Transact()方法是一个native方法。我们之前说了，对于客户端来说，操作代理和操作实际的Binder对象是一样的，这是因为，代理类会负责将参数及各种请求信息封装后通过内核驱动传递给真正的Binder类，再由该类去执行相关操作。在这里，Proxy的myAdd()方法最终会通过系统将请求送到服务端的本地Binder类中去，onTransact方法将被调用。\n\n肯定是要来看onTransact()方法代码的：\n\n```Java\n@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException\n{\nswitch (code)\n{\ncase INTERFACE_TRANSACTION:\n{\nreply.writeString(DESCRIPTOR);\nreturn true;\n}\ncase TRANSACTION_myAdd:\n{\ndata.enforceInterface(DESCRIPTOR);\nint _arg0;\n_arg0 = data.readInt();\nint _arg1;\n_arg1 = data.readInt();\nint _result = this.myAdd(_arg0, _arg1);\nreply.writeNoException();\nreply.writeInt(_result);\nreturn true;\n}\n}\nreturn super.onTransact(code, data, reply, flags);\n}\n```\n服务端将通过code知道客户端的具体请求是什么，然后从data中取出目标方法参数，执行目标方法myAdd()。这个myAdd()方法不再是其他的假象，而是我们在服务端Service中定义的那个方法:\n\n```Java\nOverride\npublic int myAdd(int num_a, int num_b) throws RemoteException {\n    int result=num_a+num_b;\n    Log.d(\"ServerService\",\"the result of \"+num_a+\" and \"+num_b+\" is \"+result);\n    return result;\n}\n```\n然后，onTransact()方法将得到的结果写入reply,最终通过系统返回给客户端。客户端可以接着执行之后的打印操作了。所以，在客户端要对远程服务发起请求，而这个请求又相当耗时的情况下，一定不能在UI线程中发起该请求！\n\n到这里，我们上一节中讲的AIDL执行流程就全部结束了。终于把思路理清楚了，如果有错误的话还是希望能够留言指出哦~\n\n\n\n\n\n\n","tags":["Android"]},{"title":"Android IPC 之 AIDL（一）","url":"/2018/05/08/AIDL_1/","content":"IPC是Inter-Process Communication的缩写，即跨进程通信。Android中跨进程通信有多种方式，如Intent、文件共享、使用ContentProvider、Broadcast、和Socket等。比较复杂的情况下，常用的两种方式为Messenger和AIDL,而Messenger的底层实现又是AIDL。\n\n首先不看别的，先来看一下AIDL是如何使用的。\n\n假设我们现在有一个两数相加的任务，客户端没办法完成（别问我它为什么完不成==，咱举栗子简单点哈~），需要将任务交给另一个进程中的服务端完成，再从服务端获取到该任务的结果。\n\n我们首先如下图方式创建一个AIDL接口：\n\n![](/img/01.png)\n\nAndroid Studio会自动为它生成一个路径，如下图：\n\n![](/img/02.png)\n\n在该文件中声明一个接口以及一个我们想让服务端实现的接口方法。如下：\n\n```Java\npackage com.vera.aidltest;\ninterface IMyAdd {\n    int myAdd(int num_a,int num_b);\n}\n```\n\n注意，并不是所有数据类型都能在AIDL文件中使用，AIDL文件只支持以下几种数据类型：\n- Java 中的基本数据类型\n- String 和CharSequence\n- List 和 Map ,且List和Map 对象的元素必须是AIDL支持的数据类型\n- AIDL 自动生成的接口 ，需要导入(import，即使同处于一个包中)\n- 实现android.os.Parcelable 接口的类的对象. 需要导入(import，即使同处于一个包中)，且必须新建一个与其同名的AIDL文件，并在文件中声明该类为Parcelable\n\n在接口定义好后，系统将为我们生成一个Java文件，AS下是在app\\build\\generated\\source\\aidl\\debug目录下，生成的代码如下：\n```Java\npackage com.vera.aidltest;\npublic interface IMyAdd extends android.os.IInterface\n{\n/** Local-side IPC implementation stub class. */\npublic static abstract class Stub extends android.os.Binder implements com.vera.aidltest.IMyAdd\n{\nprivate static final java.lang.String DESCRIPTOR = \"com.vera.aidltest.IMyAdd\";\n/** Construct the stub at attach it to the interface. */\npublic Stub()\n{\nthis.attachInterface(this, DESCRIPTOR);\n}\n/**\n* Cast an IBinder object into an com.vera.aidltest.IMyAdd interface,\n* generating a proxy if needed.\n*/\npublic static com.vera.aidltest.IMyAdd asInterface(android.os.IBinder obj)\n{\nif ((obj==null)) {\nreturn null;\n}\nandroid.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);\nif (((iin!=null)&&(iin instanceof com.vera.aidltest.IMyAdd))) {\nreturn ((com.vera.aidltest.IMyAdd)iin);\n}\nreturn new com.vera.aidltest.IMyAdd.Stub.Proxy(obj);\n}\n@Override public android.os.IBinder asBinder()\n{\nreturn this;\n}\n@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException\n{\nswitch (code)\n{\ncase INTERFACE_TRANSACTION:\n{\nreply.writeString(DESCRIPTOR);\nreturn true;\n}\ncase TRANSACTION_myAdd:\n{\ndata.enforceInterface(DESCRIPTOR);\nint _arg0;\n_arg0 = data.readInt();\nint _arg1;\n_arg1 = data.readInt();\nint _result = this.myAdd(_arg0, _arg1);\nreply.writeNoException();\nreply.writeInt(_result);\nreturn true;\n}\n}\nreturn super.onTransact(code, data, reply, flags);\n}\nprivate static class Proxy implements com.vera.aidltest.IMyAdd\n{\nprivate android.os.IBinder mRemote;\nProxy(android.os.IBinder remote)\n{\nmRemote = remote;\n}\n@Override public android.os.IBinder asBinder()\n{\nreturn mRemote;\n}\npublic java.lang.String getInterfaceDescriptor()\n{\nreturn DESCRIPTOR;\n}\n@Override public int myAdd(int num_a, int num_b) throws android.os.RemoteException\n{\nandroid.os.Parcel _data = android.os.Parcel.obtain();\nandroid.os.Parcel _reply = android.os.Parcel.obtain();\nint _result;\ntry {\n_data.writeInterfaceToken(DESCRIPTOR);\n_data.writeInt(num_a);\n_data.writeInt(num_b);\nmRemote.transact(Stub.TRANSACTION_myAdd, _data, _reply, 0);\n_reply.readException();\n_result = _reply.readInt();\n}\nfinally {\n_reply.recycle();\n_data.recycle();\n}\nreturn _result;\n}\n}\nstatic final int TRANSACTION_myAdd = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);\n}\npublic int myAdd(int num_a, int num_b) throws android.os.RemoteException;\n}\n```\n\n代码很长很凌乱的样子……嗯，本节我们先不看它，只需要知道它是根据AIDL文件生成的一个接口IMyAdd，包含一个继承自Binder的静态内部抽象类Stub（咦，这么连起来说总有哪里怪怪的……），并且声明了myAdd()方法。为什么是抽象类呢，因为它实现了IMyAdd接口却并没有真正实现，那放到哪里实现呢？当然是我们的服务端咯。\n\n接下来，我们可以就可以来写客户端和服务端的代码了，那么，我们这里的客户端和服务端指的是什么呢？就本例来说，它们分别是一个Activity和一个Service，这里我们将它们放在了同一个应用中，只不过通过某种方法使其运行在不同的进程。更多情况下它们并不运行在同一个应用中，这时候我们需要将整个aidl文件夹的内容复制一份，这是因为客户端和服务端的AIDL包结构需要保持一致，否则将会出现反序列化不成功的结果，那么跨进程通信将无法进行。\n\n那么我们现在开始写服务端的代码，新建一个Service名为ServerService如下：\n```Java\npackage com.vera.aidltest;\nimport android.app.Service;\nimport android.content.Intent;\nimport android.os.Binder;\nimport android.os.IBinder;\nimport android.os.RemoteException;\nimport android.util.Log;\npublic class ServerService extends Service {\n    private Binder mBinder=new IMyAdd.Stub(){\n        @Override\n        public int myAdd(int num_a, int num_b) throws RemoteException {\n            int result=num_a+num_b;\n            Log.d(\"ServerService\",\"the result of \"+num_a+\" and \"+num_b+\" is \"+result);\n            return result;\n        }\n        };\n        @Override\n        public IBinder onBind(Intent intent) {\n            return mBinder;\n        }\n}\n```\nServerService很简单，它只是创建了一个Binder对象并在onBinder()方法中将其返回。该Binder对象就是我们实现了接口方法的Stub对象。好啦，现在我们可以在myAdd()方法中愉快地进行我们的操作啦。在这里我们只是得到num_a和num_b的和并将其打印，最后再返回结果。\n\n另外，我们需要将该Service设置在一个独立的进程中，不然还怎么玩跨进程通信~\n更改AndroidManifest.xml如下：\n```xml\n<service\n    android:name=\".ServerService\"\n    android:process=\":remote\">\n</service>\n```\n好了，服务端的创建已经完成啦，我们现在来看客户端。客户端要做些什么呢？，我们来看代码：\n```Java\npackage com.vera.aidltest;\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.os.Bundle;\nimport android.os.IBinder;\nimport android.os.RemoteException;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.Button;\npublic class ClientActivity extends AppCompatActivity {\n    Button mButton;\n    private ServiceConnection myConnection=new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {\n                IMyAdd mMyAdd=IMyAdd.Stub.asInterface(iBinder);\n                try {\n                    int result=mMyAdd.myAdd(1,2);\n                    Log.d(\"ClientActivity\",\"get the result is \"+result);\n                } catch (RemoteException e) {\n                    e.printStackTrace();\n                }\n        }\n        @Override\n        public void onServiceDisconnected(ComponentName componentName) {\n        }\n    };\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_client);\n        mButton=(Button)findViewById(R.id.activity_client_mbutton);\n        mButton.setOnClickListener(new View.OnClickListener() {\n                            @Override\n                            public void onClick(View view) {\n                                Intent intent=new Intent(ClientActivity.this,ServerService.class);\n                                bindService(intent,myConnection, Context.BIND_AUTO_CREATE);\n                            }});\n    }\n    @Override\n    protected void onDestroy(){\n        unbindService(myConnection);\n        super.onDestroy();\n    }\n}\n```\n首先，我们创建了一个ServiceConnection的匿名类并实例化一个对象，然后，我们又设置了在Button点击之后通过bindService()方法绑定服务。bindService()方法接收三个参数，第一个是在这之前我们创建的Intent对象，第二个是ServiceConnection的实例对象，第三个参数是一个标志位，BIND_AUTO_CREATE表示在Activity和Service进行绑定后，服务将自动创建。然后我们重写了onDestroy()方法，将Activity和Service解除绑定。\n\n重点是在创建的ServiceConnection匿名类里！在这个类里我们重写了onServiceConnected()方法和onServiceDisconnected()方法,这两个方法分别会在Activity与Service成功绑定和解除绑定的时候调用。在onServiceConnected()方法里，我们调用了Stub()的asInterface()方法,该方法返回一个Binder代理对象，并向上转型成为客户端接受的AIDL接口类型的对象！\n\n好啦，拿到了这个对象，现在只差一步调用方法的事啦，我们来试一试1+2等于多少叭~\n\n运行程序，在点击Button之后，查看日志打印信息，如下图：\n\n![](/img/03.png)\n\n在com.vera.aidltest进程中，客户端打印出得到的结果为3,在com.vera.aidltest:remote进程中，服务端打印出1+2等于3，通信成功啦！\n\n嗯好，那我们来总结一下，具体的步骤吧：\n- 首先建立一个AIDL文件，在其中定义一个接口，接口中应包含我们希望服务端实现的方法的声明。\n- 其次，在服务端中将实现好方法的Stub对象通过onBind()方法返回\n- 最后，在客户端中将服务绑定，并重写ServiceConnection类中的方法，在其中获得Binder对象，调用服务端的接口方法。\n\n这其中我们屏蔽了很多细节，只谈了使用方法，下一节婷子会把更具体的部分再贴出来，第一篇技术博客，有什么不对的地方还请留言哦，么么哒~\n\n\n\n\n\n\n\n\n\n\n","tags":["Android"]},{"title":"Hello World","url":"/2018/05/08/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n![1234567](hhttp://img.blog.csdn.net/20160326220055843)\n"}]